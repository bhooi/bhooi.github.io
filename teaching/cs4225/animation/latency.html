<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kitten Network Concepts</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Helvetica', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .animation-section {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .section-title {
            font-size: 1.8em;
            margin-bottom: 15px;
            text-align: center;
            color: #FFE4B5;
        }

        .description {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1em;
            opacity: 0.9;
        }

        canvas {
            display: block;
            margin: 0 auto;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
        }

        .counters {
            position: absolute;
            right: 20px;
            font-size: 1.1em;
            font-weight: bold;
        }

        .bandwidth-counters {
            top: 140px;
        }

        .latency-counters {
            top: 140px;
        }

        .throughput-counters {
            top: 140px;
        }

        .counter {
            background: rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            margin-bottom: 10px;
            min-width: 150px;
            text-align: center;
        }
        
        .upper-counter {
            position: relative;
            top: -60px; /* Move upper counters up */
        }
        
        .lower-counter {
            position: relative;
            top: 0; /* Keep lower counters at normal position */
        }

        .control-panel {
            text-align: center;
            margin-top: 20px;
        }

        button {
            background: linear-gradient(45deg, #FF6B6B, #FF8E8E);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üê± Networking Concepts with Kittens üê±</h1>
        
        <!-- Bandwidth Animation -->
        <div class="animation-section">
            <h2 class="section-title">Bandwidth: Tube Thickness</h2>
            <p class="description">Bandwidth is like the width of a pipe - wider pipes allow more kittens to flow through per second!</p>
            <div style="position: relative;">
                <canvas id="bandwidthCanvas" width="800" height="300"></canvas>
                <div class="counters bandwidth-counters">
                    <div class="counter upper-counter">Thick Tube<br><span id="thickTubeCount">0</span> kittens/sec</div>
                    <div class="counter lower-counter">Thin Tube<br><span id="thinTubeCount">0</span> kittens/sec</div>
                </div>
            </div>
        </div>

        <!-- Latency Animation -->
        <div class="animation-section">
            <h2 class="section-title">Latency: Tube Length</h2>
            <p class="description">Latency is the delay - longer tubes take more time for kittens to travel through!</p>
            <div style="position: relative;">
                <canvas id="latencyCanvas" width="800" height="300"></canvas>
                <div class="counters latency-counters">
                    <div class="counter upper-counter">Short Tube<br><span id="shortLatency">0</span>ms</div>
                    <div class="counter lower-counter">Long Tube<br><span id="longLatency">0</span>ms</div>
                </div>
            </div>
        </div>

        <!-- Throughput Animation -->
        <div class="animation-section">
            <h2 class="section-title">Throughput: Actual Traffic</h2>
            <p class="description">Throughput is the actual amount of data flowing - same pipe size, different traffic!</p>
            <div style="position: relative;">
                <canvas id="throughputCanvas" width="800" height="300"></canvas>
                <div class="counters throughput-counters">
                    <div class="counter upper-counter">High Traffic<br><span id="highThroughput">0</span> kittens/sec</div>
                    <div class="counter lower-counter">Low Traffic<br><span id="lowThroughput">0</span> kittens/sec</div>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <button onclick="resetAllAnimations()">üîÑ Reset All</button>
            <button onclick="pauseAllAnimations()">‚è∏Ô∏è Pause/Resume</button>
        </div>
    </div>

    <script>
        class Kitten {
            constructor(x, y, vx, vy, size, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.baseVx = vx; // Store original horizontal speed
                this.size = size;
                this.color = color;
                this.bounceTime = 0;
                this.meowTime = 0;
                this.id = Math.random();
                this.speedChangeTimer = 0;
            }

            update(tubeTop, tubeBottom, tubeLeft, tubeRight) {
                this.x += this.vx;
                this.y += this.vy;
                
                // Random speed variation every second or when bouncing
                this.speedChangeTimer++;
                if (this.speedChangeTimer >= 60) { // Every second at 60fps
                    this.randomizeSpeed();
                    this.speedChangeTimer = 0;
                }
                
                // Strict wall collision - bounce off tube walls
                if (this.y - this.size <= tubeTop) {
                    this.y = tubeTop + this.size;
                    this.vy = Math.abs(this.vy);
                    this.bounce();
                    this.playBounceSound();
                    this.randomizeSpeed(); // Speed change on wall bounce
                }
                if (this.y + this.size >= tubeBottom) {
                    this.y = tubeBottom - this.size;
                    this.vy = -Math.abs(this.vy);
                    this.bounce();
                    this.playBounceSound();
                    this.randomizeSpeed(); // Speed change on wall bounce
                }
                
                // Keep within horizontal bounds
                if (this.x < tubeLeft + this.size) {
                    this.x = tubeLeft + this.size;
                    this.vx = Math.abs(this.vx);
                }
                if (this.x > tubeRight - this.size) {
                    this.x = tubeRight - this.size;
                    this.vx = Math.abs(this.vx);
                }
                
                this.bounceTime = Math.max(0, this.bounceTime - 1);
                this.meowTime = Math.max(0, this.meowTime - 1);
            }

            randomizeSpeed() {
                // Change horizontal speed by ¬±5%
                const variation = (Math.random() - 0.5) * 0.1; // -0.05 to +0.05 (5%)
                this.vx = this.baseVx * (1 + variation);
                // Ensure we're still moving forward
                if (this.vx < this.baseVx * 0.5) this.vx = this.baseVx * 0.5;
            }

            bounce() {
                this.bounceTime = 15;
                this.meowTime = 30;
            }

            checkCollision(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.size + other.size && distance > 0) {
                    // Play bounce sound
                    this.playBounceSound();
                    
                    // Randomize speed on collision
                    this.randomizeSpeed();
                    other.randomizeSpeed();
                    
                    // Normalize the collision vector
                    const nx = dx / distance;
                    const ny = dy / distance;
                    
                    // Separate kittens completely
                    const overlap = this.size + other.size - distance;
                    const separationDistance = overlap * 0.6;
                    
                    this.x += nx * separationDistance;
                    this.y += ny * separationDistance;
                    other.x -= nx * separationDistance;
                    other.y -= ny * separationDistance;
                    
                    // Calculate relative velocity
                    const relativeVx = this.vx - other.vx;
                    const relativeVy = this.vy - other.vy;
                    
                    // Calculate relative velocity along collision normal
                    const velocityAlongNormal = relativeVx * nx + relativeVy * ny;
                    
                    // Don't resolve if velocities are separating
                    if (velocityAlongNormal > 0) return true;
                    
                    // Apply bounce with damping
                    const restitution = 0.8;
                    const impulse = -(1 + restitution) * velocityAlongNormal / 2;
                    
                    this.vx += impulse * nx;
                    this.vy += impulse * ny;
                    other.vx -= impulse * nx;
                    other.vy -= impulse * ny;
                    
                    // Visual bounce effect
                    this.bounce();
                    other.bounce();
                    
                    return true;
                }
                return false;
            }

            playBounceSound() {
                // Create a simple beep sound using Web Audio API
                try {
                    // Reuse audio context to prevent memory leaks
                    if (!window.audioContext) {
                        window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    const audioContext = window.audioContext;
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(400 + Math.random() * 200, audioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.05, audioContext.currentTime); // Lower volume
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    
                    // Clean up after sound ends
                    setTimeout(() => {
                        try {
                            oscillator.disconnect();
                            gainNode.disconnect();
                        } catch(e) {}
                    }, 150);
                    
                } catch (e) {
                    // Fallback: just do visual bounce if audio fails
                }
            }

            draw(ctx) {
                const bounceScale = this.bounceTime > 0 ? 1.2 : 1.0;
                const size = this.size * bounceScale;
                
                // Kitten body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Ears
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x - size * 0.6, this.y - size * 0.6, size * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x + size * 0.6, this.y - size * 0.6, size * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(this.x - size * 0.3, this.y - size * 0.2, size * 0.15, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x + size * 0.3, this.y - size * 0.2, size * 0.15, 0, Math.PI * 2);
                ctx.fill();
                
                // Nose
                ctx.fillStyle = 'pink';
                ctx.beginPath();
                ctx.arc(this.x, this.y + size * 0.1, size * 0.1, 0, Math.PI * 2);
                ctx.fill();
                
                // Meow effect
                if (this.meowTime > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = `${size * 0.8}px Helvetica`;
                    ctx.textAlign = 'center';
                    ctx.fillText('meow!', this.x, this.y - size * 1.5);
                }
            }
        }

        class NetworkAnimation {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.kittens = [];
                this.counters = {};
                this.lastTime = 0;
                this.paused = false;
                this.spawnTimer = 0;
            }

            drawTube(x, y, width, height, color = '#8B4513') {
                const ctx = this.ctx;
                
                // Tube walls (narrower)
                ctx.fillStyle = color;
                ctx.fillRect(x, y, width, 8); // Top wall
                ctx.fillRect(x, y + height - 8, width, 8); // Bottom wall
                
                // Tube interior (much more contrasting - white with subtle shadows)
                const gradient = ctx.createLinearGradient(x, y, x, y + height);
                gradient.addColorStop(0, 'rgba(139, 69, 19, 0.5)'); // Brown shadow at top
                gradient.addColorStop(0.15, 'rgba(255, 255, 255, 0.95)'); // Bright white
                gradient.addColorStop(0.5, 'rgba(248, 248, 255, 1)'); // Very light blue-white
                gradient.addColorStop(0.85, 'rgba(255, 255, 255, 0.95)'); // Bright white
                gradient.addColorStop(1, 'rgba(139, 69, 19, 0.5)'); // Brown shadow at bottom
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y + 8, width, height - 16);
                
                // Add some depth with a border
                ctx.strokeStyle = 'rgba(139, 69, 19, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y + 8, width, height - 16);
                
                // Inner highlight for more depth
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(x + 1, y + 9, width - 2, height - 18);
            }

            update() {
                if (this.paused) return;
                
                this.spawnTimer++;
                
                // Update all kittens
                for (let i = this.kittens.length - 1; i >= 0; i--) {
                    const kitten = this.kittens[i];
                    this.updateKitten(kitten);
                    
                    // Remove kittens that have exited
                    if (this.shouldRemoveKitten(kitten)) {
                        this.kittens.splice(i, 1);
                    }
                }
                
                // Check collisions
                for (let i = 0; i < this.kittens.length; i++) {
                    for (let j = i + 1; j < this.kittens.length; j++) {
                        this.kittens[i].checkCollision(this.kittens[j]);
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawScene();
                
                for (const kitten of this.kittens) {
                    kitten.draw(this.ctx);
                }
            }

            reset() {
                this.kittens = [];
                this.counters = {};
                this.spawnTimer = 0;
                
                // Clear any audio context references to prevent memory leaks
                if (window.audioContext && window.audioContext.state !== 'closed') {
                    try {
                        window.audioContext.close().then(() => {
                            window.audioContext = null;
                        });
                    } catch(e) {
                        window.audioContext = null;
                    }
                }
            }

            pause() {
                this.paused = !this.paused;
            }
        }

        class BandwidthAnimation extends NetworkAnimation {
            constructor() {
                super('bandwidthCanvas');
                this.thickCount = 0;
                this.thinCount = 0;
                this.countTimer = 0;
            }

            updateKitten(kitten) {
                // Determine which tube the kitten is in (adjusted for narrower walls)
                const tubeTop = kitten.tubeId === 'thick' ? 58 : 208; // 50 + 8
                const tubeBottom = kitten.tubeId === 'thick' ? 142 : 242; // 150 - 8, 250 - 8
                
                kitten.update(tubeTop, tubeBottom, 50, 750);
            }

            shouldRemoveKitten(kitten) {
                if (kitten.x >= 750 - kitten.size) {
                    if (kitten.tubeId === 'thick') {
                        this.thickCount++;
                    } else {
                        this.thinCount++;
                    }
                    return true;
                }
                return false;
            }

            drawScene() {
                // Draw thick tube
                this.drawTube(50, 50, 700, 100);
                
                // Draw thin tube
                this.drawTube(50, 200, 700, 50);
                
                // Labels
                this.ctx.fillStyle = 'black';
                this.ctx.font = '16px Helvetica';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('High Bandwidth (Thick Tube)', 400, 30);
                this.ctx.fillText('Low Bandwidth (Thin Tube)', 400, 185);
                
                // Spawn kittens
                if (this.spawnTimer % 30 === 0) { // Thick tube - more frequent
                    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
                    for (let i = 0; i < 2; i++) {
                        const kitten = new Kitten(60, 85 + Math.random() * 30, 2.5, (Math.random() - 0.5) * 1, 12, colors[Math.floor(Math.random() * colors.length)]);
                        kitten.tubeId = 'thick';
                        this.kittens.push(kitten);
                    }
                }
                
                if (this.spawnTimer % 90 === 0) { // Thin tube - less frequent
                    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
                    const kitten = new Kitten(60, 225, 2.5, 0, 12, colors[Math.floor(Math.random() * colors.length)]);
                    kitten.tubeId = 'thin';
                    this.kittens.push(kitten);
                }
                
                // Update counters every second
                this.countTimer++;
                if (this.countTimer >= 60) {
                    document.getElementById('thickTubeCount').textContent = this.thickCount;
                    document.getElementById('thinTubeCount').textContent = this.thinCount;
                    this.thickCount = 0;
                    this.thinCount = 0;
                    this.countTimer = 0;
                }
            }
        }

        class LatencyAnimation extends NetworkAnimation {
            constructor() {
                super('latencyCanvas');
                this.latencyData = new Map();
                this.shortLatency = 0;
                this.longLatency = 0;
            }

            updateKitten(kitten) {
                const tubeTop = kitten.tubeId === 'short' ? 58 : 208; // 50 + 8
                const tubeBottom = kitten.tubeId === 'short' ? 117 : 267; // 125 - 8, 275 - 8
                
                kitten.update(tubeTop, tubeBottom, 50, kitten.tubeId === 'short' ? 450 : 750);
            }

            shouldRemoveKitten(kitten) {
                const exitX = kitten.tubeId === 'short' ? 450 - kitten.size : 750 - kitten.size;
                if (kitten.x >= exitX) {
                    if (this.latencyData.has(kitten.id)) {
                        const latency = Date.now() - this.latencyData.get(kitten.id);
                        if (kitten.tubeId === 'short') {
                            this.shortLatency = Math.round(latency);
                        } else {
                            this.longLatency = Math.round(latency);
                        }
                        this.latencyData.delete(kitten.id);
                    }
                    return true;
                }
                return false;
            }

            reset() {
                super.reset();
                this.latencyData.clear(); // Clear the Map to prevent memory leaks
                this.shortLatency = 0;
                this.longLatency = 0;
            }

            drawScene() {
                // Draw short tube
                this.drawTube(50, 50, 400, 75);
                
                // Draw long tube
                this.drawTube(50, 200, 700, 75);
                
                // Labels
                this.ctx.fillStyle = 'black';
                this.ctx.font = '16px Helvetica';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Low Latency (Short Tube)', 250, 30);
                this.ctx.fillText('High Latency (Long Tube)', 400, 185);
                
                // Spawn kittens
                if (this.spawnTimer % 90 === 0) {
                    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
                    
                    // Short tube kitten
                    const shortKitten = new Kitten(60, 87, 2.5, 0, 12, colors[Math.floor(Math.random() * colors.length)]);
                    shortKitten.tubeId = 'short';
                    this.latencyData.set(shortKitten.id, Date.now());
                    this.kittens.push(shortKitten);
                    
                    // Long tube kitten
                    const longKitten = new Kitten(60, 237, 2.5, 0, 12, colors[Math.floor(Math.random() * colors.length)]);
                    longKitten.tubeId = 'long';
                    this.latencyData.set(longKitten.id, Date.now());
                    this.kittens.push(longKitten);
                }
                
                // Update latency displays
                document.getElementById('shortLatency').textContent = this.shortLatency;
                document.getElementById('longLatency').textContent = this.longLatency;
            }
        }

        class ThroughputAnimation extends NetworkAnimation {
            constructor() {
                super('throughputCanvas');
                this.highCount = 0;
                this.lowCount = 0;
                this.countTimer = 0;
            }

            updateKitten(kitten) {
                const tubeTop = kitten.tubeId === 'high' ? 58 : 208; // 50 + 8
                const tubeBottom = kitten.tubeId === 'high' ? 142 : 292; // 150 - 8, 300 - 8
                
                kitten.update(tubeTop, tubeBottom, 50, 750);
            }

            shouldRemoveKitten(kitten) {
                if (kitten.x >= 750 - kitten.size) {
                    if (kitten.tubeId === 'high') {
                        this.highCount++;
                    } else {
                        this.lowCount++;
                    }
                    return true;
                }
                return false;
            }

            drawScene() {
                // Draw tubes (same size)
                this.drawTube(50, 50, 700, 100);
                this.drawTube(50, 200, 700, 100);
                
                // Labels
                this.ctx.fillStyle = 'black';
                this.ctx.font = '16px Comic Sans MS';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('High Throughput (More Traffic)', 400, 30);
                this.ctx.fillText('Low Throughput (Less Traffic)', 400, 180);
                
                // Spawn kittens - high throughput tube gets more kittens
                if (this.spawnTimer % 45 === 0) {
                    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
                    for (let i = 0; i < 2; i++) {
                        const kitten = new Kitten(60, 100 + Math.random() * 50, 2, (Math.random() - 0.5) * 2, 12, colors[Math.floor(Math.random() * colors.length)]);
                        kitten.tubeId = 'high';
                        this.kittens.push(kitten);
                    }
                }
                
                if (this.spawnTimer % 180 === 0) {
                    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
                    const kitten = new Kitten(60, 250 + Math.random() * 50, 2, (Math.random() - 0.5) * 2, 12, colors[Math.floor(Math.random() * colors.length)]);
                    kitten.tubeId = 'low';
                    this.kittens.push(kitten);
                }
                
                // Update counters
                this.countTimer++;
                if (this.countTimer >= 60) {
                    document.getElementById('highThroughput').textContent = this.highCount;
                    document.getElementById('lowThroughput').textContent = this.lowCount;
                    this.highCount = 0;
                    this.lowCount = 0;
                    this.countTimer = 0;
                }
            }
        }

        // Initialize animations
        const bandwidthAnim = new BandwidthAnimation();
        const latencyAnim = new LatencyAnimation();
        const throughputAnim = new ThroughputAnimation();
        
        let animationId;
        let frameCount = 0;
        
        function animate() {
            bandwidthAnim.update();
            bandwidthAnim.draw();
            
            latencyAnim.update();
            latencyAnim.draw();
            
            throughputAnim.update();
            throughputAnim.draw();
            
            // Memory management: limit total kittens across all animations
            frameCount++;
            if (frameCount % 300 === 0) { // Every 5 seconds
                const totalKittens = bandwidthAnim.kittens.length + 
                                   latencyAnim.kittens.length + 
                                   throughputAnim.kittens.length;
                
                if (totalKittens > 50) { // Prevent too many kittens
                    // Remove oldest kittens if we have too many
                    [bandwidthAnim, latencyAnim, throughputAnim].forEach(anim => {
                        if (anim.kittens.length > 15) {
                            anim.kittens.splice(0, anim.kittens.length - 15);
                        }
                    });
                }
            }
            
            animationId = requestAnimationFrame(animate);
        }

        function resetAllAnimations() {
            bandwidthAnim.reset();
            latencyAnim.reset();
            throughputAnim.reset();
            
            // Reset counters
            document.getElementById('thickTubeCount').textContent = '0';
            document.getElementById('thinTubeCount').textContent = '0';
            document.getElementById('shortLatency').textContent = '0';
            document.getElementById('longLatency').textContent = '0';
            document.getElementById('highThroughput').textContent = '0';
            document.getElementById('lowThroughput').textContent = '0';
        }

        function pauseAllAnimations() {
            bandwidthAnim.pause();
            latencyAnim.pause();
            throughputAnim.pause();
        }

        // Start the animation
        animate();
    </script>
</body>
</html>